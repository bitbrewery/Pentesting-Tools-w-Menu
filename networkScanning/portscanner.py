# Importing necessary libraries
from scapy.all import *
import threading
import queue
import time
import socket

# Creating a Queue to store the results
results = queue.Queue()

# List to hold all threads
threads = []

# Creating a Lock object for synchronization
lock = threading.Lock()

# Function to check each port
def check_port(target, port, timeout):
    try:
        # Sending TCP request
        tcp_res = sr1(IP(dst=target) / TCP(dport=port), timeout=timeout, verbose=0)

        # Sending UDP request
        udp_res = sr1(IP(dst=target) / UDP(dport=port), timeout=timeout, verbose=0)

        # Trying to get the service name for the port
        try:
            service = socket.getservbyport(port, "tcp") if tcp_res else "unknown"
        except OSError:
            service = "unknown service"

        # Checking the responses and putting the result in the queue
        if tcp_res is None and udp_res is None:
            results.put(f"No response from port {port} (TCP/UDP). Service: {service}")
        elif tcp_res is not None and tcp_res[TCP].flags == 2:
            results.put(f"Port {port} (TCP): Open. Service: {service}")
        elif udp_res is not None:
            results.put(f"Port {port} (UDP): Open. Service: {service}")
        else:
            results.put(f"Port {port} (TCP/UDP): Closed. Service: {service}")
    finally:
        # Releasing the lock
        lock.release()


# Main function to run the port scanner
def run_port_scanner():
    # Getting user inputs
    target = input("Enter the target IP address: ")
    ports = input("Enter the ports to scan (e.g., 80-443, 8080, 443): ")
    timeout = float(input("Enter the timeout amount (seconds): "))

    # Starting timer
    start_time = time.time()

    # Splitting the port ranges
    port_ranges = ports.split(",")

    # Looping through each port range
    for pr in port_ranges:
        # Checking if the range includes a dash (-)
        if "-" in pr:
            # Splitting the range into start and end ports
            start_port, end_port = map(int, pr.split("-"))
            # Looping through each port in the range
            for port in range(start_port, end_port + 2):
                # Acquiring the lock
                lock.acquire()
                # Creating a new thread to check the port
                t = threading.Thread(target=check_port, args=(target, port, timeout))
                t.start()
                # Adding the thread to the list of threads
                threads.append(t)
        else:
            # Converting the port to an integer
            port = int(pr)
            # Acquiring the lock
            lock.acquire()
            # Creating a new thread to check the port
            t = threading.Thread(target=check_port, args=(target, port, timeout))
            t.start()
            # Adding the thread to the list of threads
            threads.append(t)

    # Function to print the results
    def print_results():
        # Looping until the queue is empty
        while True:
            # Checking if the queue is not empty
            if not results.empty():
                # Getting the result from the queue
                result = results.get()
                # Printing the result
                print(f"{result}")
            else:
                # Breaking the loop if the queue is empty
                break

    # Creating a new thread to print the results
    print_thread = threading.Thread(target=print_results)
    print_thread.start()
    # Adding the print thread to the list of threads
    threads.append(print_thread)

    # Waiting for all threads to finish
    for t in threads:
        t.join()

    # Stopping the timer
    end_time = time.time()
    # Calculating the total execution time
    total_time = end_time - start_time
    # Printing the total execution time
    print(f"Total execution time: {total_time} seconds")

    # Asking the user to press enter to exit
    exit = input("Press Enter To Exit ...")
